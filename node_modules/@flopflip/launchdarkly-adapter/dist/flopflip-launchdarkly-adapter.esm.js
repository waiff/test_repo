import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _classCallCheck from '@babel/runtime/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime/helpers/esm/createClass';
import _classPrivateFieldLooseBase from '@babel/runtime/helpers/esm/classPrivateFieldLooseBase';
import _classPrivateFieldLooseKey from '@babel/runtime/helpers/esm/classPrivateFieldLooseKey';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { exposeGlobally, denormalizeFlagName, normalizeFlags, normalizeFlag } from '@flopflip/adapter-utilities';
import { AdapterConfigurationStatus, AdapterInitializationStatus, AdapterSubscriptionStatus, adapterIdentifiers } from '@flopflip/types';
import debounce from 'debounce-fn';
import { initialize } from 'launchdarkly-js-client-sdk';
import isEqual from 'lodash/isEqual';
import mitt from 'mitt';
import warning from 'tiny-warning';
import merge from 'ts-deepmerge';

var _adapterState = /*#__PURE__*/_classPrivateFieldLooseKey("adapterState");
var _updateFlagsInAdapterState = /*#__PURE__*/_classPrivateFieldLooseKey("updateFlagsInAdapterState");
var _getIsAdapterUnsubscribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAdapterUnsubscribed");
var _getIsFlagUnsubcribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagUnsubcribed");
var _getIsFlagLocked = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagLocked");
var _withoutUnsubscribedOrLockedFlags = /*#__PURE__*/_classPrivateFieldLooseKey("withoutUnsubscribedOrLockedFlags");
var _getIsAnonymousUser = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAnonymousUser");
var _ensureUser = /*#__PURE__*/_classPrivateFieldLooseKey("ensureUser");
var _initializeClient = /*#__PURE__*/_classPrivateFieldLooseKey("initializeClient");
var _changeUserContext = /*#__PURE__*/_classPrivateFieldLooseKey("changeUserContext");
var _getInitialFlags = /*#__PURE__*/_classPrivateFieldLooseKey("getInitialFlags");
var _didFlagChange = /*#__PURE__*/_classPrivateFieldLooseKey("didFlagChange");
var _setupFlagSubcription = /*#__PURE__*/_classPrivateFieldLooseKey("setupFlagSubcription");
var LaunchDarklyAdapter = /*#__PURE__*/function () {
  function LaunchDarklyAdapter() {
    var _this = this;
    _classCallCheck(this, LaunchDarklyAdapter);
    Object.defineProperty(this, _adapterState, {
      writable: true,
      value: void 0
    });
    this.id = void 0;
    Object.defineProperty(this, _updateFlagsInAdapterState, {
      writable: true,
      value: function value(flags, options) {
        var updatedFlags = Object.entries(flags).reduce(function (updatedFlags, _ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            flagName = _ref2[0],
            flagValue = _ref2[1];
          if (_classPrivateFieldLooseBase(_this, _getIsFlagLocked)[_getIsFlagLocked](flagName)) return updatedFlags;
          if (options !== null && options !== void 0 && options.lockFlags) {
            _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].lockedFlags.add(flagName);
          }
          if (options !== null && options !== void 0 && options.unsubscribeFlags) {
            _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].unsubscribedFlags.add(flagName);
          }
          updatedFlags = _objectSpread(_objectSpread({}, updatedFlags), {}, _defineProperty({}, flagName, flagValue));
          return updatedFlags;
        }, {});
        _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].flags = _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].flags), updatedFlags);
      }
    });
    Object.defineProperty(this, _getIsAdapterUnsubscribed, {
      writable: true,
      value: function value() {
        return _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].subscriptionStatus === AdapterSubscriptionStatus.Unsubscribed;
      }
    });
    Object.defineProperty(this, _getIsFlagUnsubcribed, {
      writable: true,
      value: function value(flagName) {
        return _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].unsubscribedFlags.has(flagName);
      }
    });
    Object.defineProperty(this, _getIsFlagLocked, {
      writable: true,
      value: function value(flagName) {
        return _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].lockedFlags.has(flagName);
      }
    });
    Object.defineProperty(this, _withoutUnsubscribedOrLockedFlags, {
      writable: true,
      value: function value(flags) {
        return Object.fromEntries(Object.entries(flags).filter(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
            flagName = _ref4[0];
          return !_classPrivateFieldLooseBase(_this, _getIsFlagUnsubcribed)[_getIsFlagUnsubcribed](flagName) && !_classPrivateFieldLooseBase(_this, _getIsFlagLocked)[_getIsFlagLocked](flagName);
        }));
      }
    });
    Object.defineProperty(this, _getIsAnonymousUser, {
      writable: true,
      value: function value(user) {
        return !(user !== null && user !== void 0 && user.key);
      }
    });
    Object.defineProperty(this, _ensureUser, {
      writable: true,
      value: function value(user) {
        var isAnonymousUser = _classPrivateFieldLooseBase(_this, _getIsAnonymousUser)[_getIsAnonymousUser](user);

        // NOTE: When marked `anonymous` the SDK will generate a unique key and cache it in local storage
        return merge(user, {
          key: isAnonymousUser ? undefined : user.key,
          anonymous: isAnonymousUser
        });
      }
    });
    Object.defineProperty(this, _initializeClient, {
      writable: true,
      value: function value(clientSideId, user, options) {
        return initialize(clientSideId, user, options);
      }
    });
    Object.defineProperty(this, _changeUserContext, {
      writable: true,
      value: function () {
        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(nextUser) {
          var _classPrivateFieldLoo;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", (_classPrivateFieldLoo = _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.identify ? _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client.identify(nextUser) : Promise.reject(new Error('Can not change user context: client not yet initialized.')));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function value(_x) {
          return _value.apply(this, arguments);
        }
        return value;
      }()
    });
    Object.defineProperty(this, _getInitialFlags, {
      writable: true,
      value: function () {
        var _value2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {
          var flags, throwOnInitializationFailure;
          return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  flags = _ref5.flags, throwOnInitializationFailure = _ref5.throwOnInitializationFailure;
                  if (!_classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client) {
                    _context4.next = 3;
                    break;
                  }
                  return _context4.abrupt("return", _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client.waitForInitialization().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                    var flagsFromSdk, _i, _Object$entries, _ref9, _ref8, requestedFlagName, defaultFlagValue, denormalizedRequestedFlagName, normalizedFlags, _flags;
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (_classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client && !flags) {
                              flagsFromSdk = _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client.allFlags();
                            } else if (_classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client && flags) {
                              flagsFromSdk = {};
                              for (_i = 0, _Object$entries = Object.entries(flags); _i < _Object$entries.length; _i++) {
                                _ref9 = _Object$entries[_i];
                                _ref8 = _slicedToArray(_ref9, 2);
                                requestedFlagName = _ref8[0];
                                defaultFlagValue = _ref8[1];
                                denormalizedRequestedFlagName = denormalizeFlagName(requestedFlagName);
                                flagsFromSdk[denormalizedRequestedFlagName] = _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client.variation(denormalizedRequestedFlagName, defaultFlagValue);
                              }
                            }
                            if (flagsFromSdk) {
                              normalizedFlags = normalizeFlags(flagsFromSdk);
                              _flags = _classPrivateFieldLooseBase(_this, _withoutUnsubscribedOrLockedFlags)[_withoutUnsubscribedOrLockedFlags](normalizedFlags);
                              _this.updateFlags(_flags);
                            }
                            _this.setConfigurationStatus(AdapterConfigurationStatus.Configured);
                            return _context2.abrupt("return", Promise.resolve({
                              flagsFromSdk: flagsFromSdk,
                              initializationStatus: AdapterInitializationStatus.Succeeded
                            }));
                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }))).catch( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!throwOnInitializationFailure) {
                              _context3.next = 2;
                              break;
                            }
                            return _context3.abrupt("return", Promise.reject(new Error('@flopflip/launchdarkly-adapter: adapter failed to initialize.')));
                          case 2:
                            console.warn('@flopflip/launchdarkly-adapter: adapter failed to initialize.');
                            return _context3.abrupt("return", Promise.resolve({
                              flagsFromSdk: undefined,
                              initializationStatus: AdapterInitializationStatus.Failed
                            }));
                          case 4:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }))));
                case 3:
                  return _context4.abrupt("return", Promise.reject(new Error('@flopflip/launchdarkly-adapter: can not subscribe with non initialized client.')));
                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));
        function value(_x2) {
          return _value2.apply(this, arguments);
        }
        return value;
      }()
    });
    Object.defineProperty(this, _didFlagChange, {
      writable: true,
      value: function value(flagName, nextFlagValue) {
        var previousFlagValue = _this.getFlag(flagName);
        if (previousFlagValue === undefined) return true;
        return previousFlagValue !== nextFlagValue;
      }
    });
    Object.defineProperty(this, _setupFlagSubcription, {
      writable: true,
      value: function value(_ref11) {
        var flagsFromSdk = _ref11.flagsFromSdk,
          flagsUpdateDelayMs = _ref11.flagsUpdateDelayMs;
        var _loop = function _loop(flagName) {
          // Dispatch whenever a configured flag value changes
          if (Object.prototype.hasOwnProperty.call(flagsFromSdk, flagName) && _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client) {
            _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].client.on("change:".concat(flagName), function (flagValue) {
              var _normalizeFlag = normalizeFlag(flagName, flagValue),
                _normalizeFlag2 = _slicedToArray(_normalizeFlag, 2),
                normalizedFlagName = _normalizeFlag2[0],
                normalizedFlagValue = _normalizeFlag2[1];
              if (_classPrivateFieldLooseBase(_this, _getIsFlagUnsubcribed)[_getIsFlagUnsubcribed](normalizedFlagName)) return;

              // Sometimes the SDK flushes flag changes without a value having changed.
              if (!_classPrivateFieldLooseBase(_this, _didFlagChange)[_didFlagChange](normalizedFlagName, normalizedFlagValue)) return;
              var updatedFlags = _defineProperty({}, normalizedFlagName, normalizedFlagValue);

              // NOTE: Adapter state needs to be updated outside of debounced-fn
              // so that no flag updates are lost.
              _classPrivateFieldLooseBase(_this, _updateFlagsInAdapterState)[_updateFlagsInAdapterState](updatedFlags);
              var flushFlagsUpdate = function flushFlagsUpdate() {
                _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].flags);
              };
              var scheduleImmediately = {
                before: true,
                after: false
              };
              var scheduleTrailingEdge = {
                before: false,
                after: true
              };
              debounce(flushFlagsUpdate, _objectSpread({
                wait: flagsUpdateDelayMs
              }, flagsUpdateDelayMs ? scheduleTrailingEdge : scheduleImmediately))();
            });
          }
        };
        for (var flagName in flagsFromSdk) {
          _loop(flagName);
        }
      }
    });
    this.updateFlags = function (flags, options) {
      _classPrivateFieldLooseBase(_this, _updateFlagsInAdapterState)[_updateFlagsInAdapterState](flags, options);

      // ...and flush initial state of flags
      _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].flags);
    };
    this.unsubscribe = function () {
      _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Unsubscribed;
    };
    this.subscribe = function () {
      _classPrivateFieldLooseBase(_this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Subscribed;
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = {
      subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
      configurationStatus: AdapterConfigurationStatus.Unconfigured,
      user: undefined,
      client: undefined,
      flags: {},
      // Typings are incorrect and state that mitt is not callable.
      // Value of type 'MittStatic' is not callable. Did you mean to include 'new'
      emitter: mitt(),
      lockedFlags: new Set(),
      unsubscribedFlags: new Set()
    };
    this.id = adapterIdentifiers.launchdarkly;
  }
  _createClass(LaunchDarklyAdapter, [{
    key: "configure",
    value: function () {
      var _configure = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(adapterArgs, adapterEventHandlers) {
        var _this2 = this,
          _sdk$clientOptions;
        var handleFlagsChange, handleStatusChange, sdk, user, flags, _adapterArgs$subscrib, subscribeToFlagChanges, _adapterArgs$throwOnI, throwOnInitializationFailure, flagsUpdateDelayMs;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                handleFlagsChange = function handleFlagsChange(nextFlags) {
                  if (_classPrivateFieldLooseBase(_this2, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
                  adapterEventHandlers.onFlagsStateChange({
                    flags: nextFlags,
                    id: _this2.id
                  });
                };
                handleStatusChange = function handleStatusChange(nextStatus) {
                  if (_classPrivateFieldLooseBase(_this2, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
                  adapterEventHandlers.onStatusStateChange({
                    status: nextStatus,
                    id: _this2.id
                  });
                };
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = AdapterConfigurationStatus.Configuring;
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('flagsStateChange', handleFlagsChange);
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('statusStateChange', handleStatusChange);
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
                  configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
                });
                sdk = adapterArgs.sdk, user = adapterArgs.user, flags = adapterArgs.flags, _adapterArgs$subscrib = adapterArgs.subscribeToFlagChanges, subscribeToFlagChanges = _adapterArgs$subscrib === void 0 ? true : _adapterArgs$subscrib, _adapterArgs$throwOnI = adapterArgs.throwOnInitializationFailure, throwOnInitializationFailure = _adapterArgs$throwOnI === void 0 ? false : _adapterArgs$throwOnI, flagsUpdateDelayMs = adapterArgs.flagsUpdateDelayMs;
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = _classPrivateFieldLooseBase(this, _ensureUser)[_ensureUser](user);
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client = _classPrivateFieldLooseBase(this, _initializeClient)[_initializeClient](sdk.clientSideId, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user, (_sdk$clientOptions = sdk.clientOptions) !== null && _sdk$clientOptions !== void 0 ? _sdk$clientOptions : {});
                return _context5.abrupt("return", _classPrivateFieldLooseBase(this, _getInitialFlags)[_getInitialFlags]({
                  flags: flags,
                  throwOnInitializationFailure: throwOnInitializationFailure
                }).then(function (_ref12) {
                  var flagsFromSdk = _ref12.flagsFromSdk,
                    initializationStatus = _ref12.initializationStatus;
                  if (subscribeToFlagChanges && flagsFromSdk) _classPrivateFieldLooseBase(_this2, _setupFlagSubcription)[_setupFlagSubcription]({
                    flagsFromSdk: flagsFromSdk,
                    flagsUpdateDelayMs: flagsUpdateDelayMs
                  });
                  return {
                    initializationStatus: initializationStatus
                  };
                }));
              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function configure(_x3, _x4) {
        return _configure.apply(this, arguments);
      }
      return configure;
    }()
  }, {
    key: "reconfigure",
    value: function () {
      var _reconfigure = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(adapterArgs, _adapterEventHandlers) {
        var nextUser;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured)) {
                  _context6.next = 2;
                  break;
                }
                return _context6.abrupt("return", Promise.reject(new Error('@flopflip/launchdarkly-adapter: please configure adapter before reconfiguring.')));
              case 2:
                nextUser = adapterArgs.user;
                if (isEqual(_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user, nextUser)) {
                  _context6.next = 8;
                  break;
                }
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = _classPrivateFieldLooseBase(this, _ensureUser)[_ensureUser](nextUser);
                _context6.next = 7;
                return _classPrivateFieldLooseBase(this, _changeUserContext)[_changeUserContext](_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user);
              case 7:
                return _context6.abrupt("return", Promise.resolve({
                  initializationStatus: AdapterInitializationStatus.Succeeded
                }));
              case 8:
                return _context6.abrupt("return", Promise.resolve({
                  initializationStatus: AdapterInitializationStatus.Succeeded
                }));
              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function reconfigure(_x5, _x6) {
        return _reconfigure.apply(this, arguments);
      }
      return reconfigure;
    }()
  }, {
    key: "getIsConfigurationStatus",
    value: function getIsConfigurationStatus(configurationStatus) {
      return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus === configurationStatus;
    }
  }, {
    key: "setConfigurationStatus",
    value: function setConfigurationStatus(nextConfigurationStatus) {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = nextConfigurationStatus;
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
        configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
      });
    }
  }, {
    key: "getClient",
    value: function getClient() {
      return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client;
    }
  }, {
    key: "getFlag",
    value: function getFlag(flagName) {
      return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags[flagName];
    }
  }, {
    key: "updateUserContext",
    value: function () {
      var _updateUserContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(updatedUserProps) {
        var isAdapterConfigured;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                isAdapterConfigured = this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured);
                warning(isAdapterConfigured, '@flopflip/launchdarkly-adapter: adapter not configured. User context can not be updated before.');
                if (isAdapterConfigured) {
                  _context7.next = 4;
                  break;
                }
                return _context7.abrupt("return", Promise.reject(new Error('Can not update user context: adapter not yet configured.')));
              case 4:
                return _context7.abrupt("return", _classPrivateFieldLooseBase(this, _changeUserContext)[_changeUserContext](_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user), updatedUserProps)));
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function updateUserContext(_x7) {
        return _updateUserContext.apply(this, arguments);
      }
      return updateUserContext;
    }()
  }]);
  return LaunchDarklyAdapter;
}();
var adapter = new LaunchDarklyAdapter();
exposeGlobally(adapter);

var version = "12.3.6";

export { adapter as default, version };
