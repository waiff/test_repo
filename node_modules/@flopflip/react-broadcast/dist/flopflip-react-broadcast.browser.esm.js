import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { useAdapterSubscription, ConfigureAdapter, createAdapterContext, AdapterContext, useAdapterContext, selectAdapterConfigurationStatus, getIsFeatureEnabled, getFlagVariation, ToggleFeature as ToggleFeature$1, setDisplayName, wrapDisplayName, DEFAULT_FLAG_PROP_KEY, DEFAULT_FLAGS_PROP_KEY } from '@flopflip/react';
export { ReconfigureAdapter as ReconfigureFlopFlip, useAdapterReconfiguration } from '@flopflip/react';
import { adapterIdentifiers, AdapterSubscriptionStatus, AdapterConfigurationStatus } from '@flopflip/types';
import React, { createContext, useMemo, useCallback, useDebugValue, useContext } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';

function createStore(initialState) {
  var state = initialState;
  var getSnapshot = function getSnapshot() {
    return state;
  };
  var listeners = new Set();
  function setState(fn) {
    state = fn(state);
    listeners.forEach(function (listener) {
      listener();
    });
  }
  function subscribe(listener) {
    listeners.add(listener);
    return function () {
      listeners.delete(listener);
    };
  }
  return {
    getSnapshot: getSnapshot,
    setState: setState,
    subscribe: subscribe
  };
}

var createIntialFlagsContext = function createIntialFlagsContext(adapterIdentifiers, initialFlags) {
  return Object.fromEntries(Object.values(adapterIdentifiers).map(function (adapterInterfaceIdentifier) {
    return [adapterInterfaceIdentifier, initialFlags];
  }));
};
var FlagsContext = /*#__PURE__*/createContext(createIntialFlagsContext(adapterIdentifiers, {}));

var initialAdapterStatus = {
  subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
  configurationStatus: AdapterConfigurationStatus.Unconfigured
};
var store = createStore({
  status: initialAdapterStatus,
  flags: {}
});
var useFlagsState = function useFlagsState(_ref) {
  var adapterIdentifiers = _ref.adapterIdentifiers;
  var flags = useSyncExternalStore(store.subscribe, function () {
    return store.getSnapshot().flags;
  }, function () {
    return store.getSnapshot().flags;
  });
  var updateFlags = useCallback(function (flagsChange) {
    store.setState(function (prevState) {
      var nextState;
      if (flagsChange.id) {
        nextState = _objectSpread(_objectSpread({}, prevState), {}, {
          flags: _objectSpread(_objectSpread({}, prevState.flags), {}, _defineProperty({}, flagsChange.id, _objectSpread(_objectSpread({}, prevState.flags[flagsChange.id]), flagsChange.flags)))
        });
        return nextState;
      }
      nextState = _objectSpread(_objectSpread({}, prevState), {}, {
        flags: _objectSpread(_objectSpread({}, prevState.flags), Object.fromEntries(adapterIdentifiers.map(function (adapterInterfaceIdentifier) {
          return [adapterInterfaceIdentifier, _objectSpread(_objectSpread({}, prevState.flags[adapterInterfaceIdentifier]), flagsChange.flags)];
        })))
      });
      return nextState;
    });
  }, [adapterIdentifiers]);
  return [flags, updateFlags];
};
var useStatusState = function useStatusState() {
  var status = useSyncExternalStore(store.subscribe, function () {
    return store.getSnapshot().status;
  }, function () {
    return store.getSnapshot().status;
  });
  var setStatus = useCallback(function (nextStatus) {
    store.setState(function (prevState) {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        status: _objectSpread(_objectSpread({}, prevState.status), nextStatus)
      });
    });
  }, []);
  return [status, setStatus];
};
function Configure(props) {
  var adapterIdentifiers = useMemo(function () {
    return [props.adapter.id];
  }, [props.adapter.id]);
  var _useFlagsState = useFlagsState({
      adapterIdentifiers: adapterIdentifiers
    }),
    _useFlagsState2 = _slicedToArray(_useFlagsState, 2),
    flags = _useFlagsState2[0],
    updateFlags = _useFlagsState2[1];
  var _useStatusState = useStatusState(),
    _useStatusState2 = _slicedToArray(_useStatusState, 2),
    status = _useStatusState2[0],
    setStatus = _useStatusState2[1];

  // NOTE:
  //   Using this prevents the callbacks being invoked
  //   which would trigger a setState as a result on an unmounted
  //   component.
  var getHasAdapterSubscriptionStatus = useAdapterSubscription(props.adapter);
  var handleUpdateFlags = useCallback(function (flagsChange) {
    if (getHasAdapterSubscriptionStatus(AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    updateFlags(flagsChange);
  }, [updateFlags, getHasAdapterSubscriptionStatus]);
  var handleUpdateStatus = useCallback(function (statusChange) {
    if (getHasAdapterSubscriptionStatus(AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    setStatus(statusChange.status);
  }, [setStatus, getHasAdapterSubscriptionStatus]);
  return /*#__PURE__*/React.createElement(FlagsContext.Provider, {
    value: flags
  }, /*#__PURE__*/React.createElement(ConfigureAdapter, {
    adapter: props.adapter,
    adapterArgs: props.adapterArgs,
    adapterStatus: status,
    defaultFlags: props.defaultFlags,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    onFlagsStateChange: handleUpdateFlags,
    onStatusStateChange: handleUpdateStatus
  }, props.children));
}
Configure.displayName = 'ConfigureFlopflip';
Configure.defaultProps = {
  defaultFlags: {},
  shouldDeferAdapterConfiguration: false
};

var defaultProps = {
  adapterIdentifiers: ['test'],
  status: {
    subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
    configurationStatus: AdapterConfigurationStatus.Configured
  }
};
function TestProvider(props) {
  var adapterContextValue = createAdapterContext(props.adapterIdentifiers, props.reconfigure, props.status);
  var flagsContextValue = createIntialFlagsContext(
  // @ts-expect-error Can not remember. Sorry to myself.
  props.adapterIdentifiers, props.flags);
  return /*#__PURE__*/React.createElement(AdapterContext.Provider, {
    value: adapterContextValue
  }, /*#__PURE__*/React.createElement(FlagsContext.Provider, {
    value: flagsContextValue
  }, props.children));
}
TestProvider.displayName = 'TestProviderFlopFlip';
TestProvider.defaultProps = defaultProps;

function useAdapterStatus() {
  var _useAdapterContext = useAdapterContext(),
    status = _useAdapterContext.status;
  var adapterStatus = selectAdapterConfigurationStatus(status.configurationStatus);
  useDebugValue({
    adapterStatus: adapterStatus
  });
  return adapterStatus;
}

var useFlagsContext = function useFlagsContext() {
  return useContext(FlagsContext);
};

function useFeatureToggle(flagName) {
  var flagVariation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var adapterContext = useAdapterContext();
  var flagsContext = useFlagsContext();
  var isFeatureEnabled = getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
  useDebugValue({
    flagName: flagName,
    flagVariation: flagVariation,
    isEnabled: isFeatureEnabled
  });
  return isFeatureEnabled;
}

function useFeatureToggles(flags) {
  var adapterContext = useAdapterContext();
  var flagsContext = useFlagsContext();
  var requestedFlags = Object.entries(flags).reduce(function (previousFlags, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      flagName = _ref2[0],
      flagVariation = _ref2[1];
    var isFeatureEnabled = getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
    return [].concat(_toConsumableArray(previousFlags), [isFeatureEnabled]);
  }, []);
  return requestedFlags;
}

function useFlagVariations(flagNames) {
  var adapterContext = useAdapterContext();
  var flagsContext = useFlagsContext();
  var flagVariations = flagNames.map(function (requestedVariation) {
    return getFlagVariation(flagsContext, adapterContext.adapterEffectIdentifiers, requestedVariation);
  });
  return flagVariations;
}

function useFlagVariation(flagName) {
  var _useFlagVariations = useFlagVariations([flagName]),
    _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
    flagVariation = _useFlagVariations2[0];
  return flagVariation;
}

function ToggleFeature(props) {
  var isFeatureEnabled = useFeatureToggle(props.flag, props.variation);

  // @ts-expect-error Never returns undefined or null.
  return /*#__PURE__*/React.createElement(ToggleFeature$1, Object.assign({}, props, {
    isFeatureEnabled: isFeatureEnabled
  }));
}
ToggleFeature.displayName = 'ToggleFeature';

function branchOnFeatureToggle(_ref, UntoggledComponent) {
  var flagName = _ref.flag,
    flagVariation = _ref.variation;
  return function (ToggledComponent) {
    function WrappedToggledComponent(ownProps) {
      var isFeatureEnabled = useFeatureToggle(flagName, flagVariation);
      if (isFeatureEnabled) return /*#__PURE__*/React.createElement(ToggledComponent, ownProps);
      if (UntoggledComponent) return /*#__PURE__*/React.createElement(UntoggledComponent, ownProps);
      return null;
    }
    return WrappedToggledComponent;
  };
}

function injectFeatureToggle(flagName) {
  var propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_FLAG_PROP_KEY;
  return function (Component) {
    function WrappedComponent(ownProps) {
      var _useFlagVariations = useFlagVariations([flagName]),
        _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
        flagVariation = _useFlagVariations2[0];
      var props = _objectSpread(_objectSpread({}, ownProps), {}, _defineProperty({}, propKey, flagVariation));
      return /*#__PURE__*/React.createElement(Component, props);
    }
    setDisplayName(wrapDisplayName(WrappedComponent, 'injectFeatureToggle'));
    return WrappedComponent;
  };
}

function injectFeatureToggles(flagNames) {
  var propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_FLAGS_PROP_KEY;
  return function (Component) {
    function WrappedComponent(ownProps) {
      var flagVariations = useFlagVariations(flagNames);
      var flags = Object.fromEntries(flagNames.map(function (flagName, indexOfFlagName) {
        return [flagName, flagVariations[indexOfFlagName]];
      }));
      var props = _objectSpread(_objectSpread({}, ownProps), {}, _defineProperty({}, propKey, flags));
      return /*#__PURE__*/React.createElement(Component, props);
    }
    setDisplayName(wrapDisplayName(WrappedComponent, 'injectFeatureToggles'));
    return WrappedComponent;
  };
}

var version = "12.3.6";

export { Configure as ConfigureFlopFlip, TestProvider as TestProviderFlopFlip, ToggleFeature, branchOnFeatureToggle, injectFeatureToggle, injectFeatureToggles, useAdapterStatus, useFeatureToggle, useFeatureToggles, useFlagVariation, useFlagVariations, version };
