import { AdapterSubscriptionStatus, AdapterConfigurationStatus, AdapterInitializationStatus } from '@flopflip/types';
import React, { createContext, Children, useState, useCallback, useRef, useEffect, useContext } from 'react';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import warning from 'tiny-warning';
import merge from 'ts-deepmerge';
import { isValidElementType } from 'react-is';
import _createForOfIteratorHelper from '@babel/runtime/helpers/esm/createForOfIteratorHelper';
import camelCase from 'lodash/camelCase';

var initialReconfigureAdapter = function initialReconfigureAdapter() {
  return undefined;
};
var initialAdapterStatus = {
  subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
  configurationStatus: AdapterConfigurationStatus.Unconfigured
};
var createAdapterContext = function createAdapterContext(adapterIdentifiers, reconfigure, status) {
  return {
    adapterEffectIdentifiers: adapterIdentifiers !== null && adapterIdentifiers !== void 0 ? adapterIdentifiers : [],
    reconfigure: reconfigure !== null && reconfigure !== void 0 ? reconfigure : initialReconfigureAdapter,
    status: status !== null && status !== void 0 ? status : initialAdapterStatus
  };
};
var initialAdapterContext = createAdapterContext();
var AdapterContext = /*#__PURE__*/createContext(initialAdapterContext);
var selectAdapterConfigurationStatus = function selectAdapterConfigurationStatus(configurationStatus) {
  var isReady = configurationStatus === AdapterConfigurationStatus.Configured;
  var isUnconfigured = configurationStatus === AdapterConfigurationStatus.Unconfigured;
  var isConfiguring = configurationStatus === AdapterConfigurationStatus.Configuring;
  var isConfigured = configurationStatus === AdapterConfigurationStatus.Configured;
  return {
    isReady: isReady,
    isUnconfigured: isUnconfigured,
    isConfiguring: isConfiguring,
    isConfigured: isConfigured
  };
};

var isFunctionChildren = function isFunctionChildren(children) {
  return typeof children === 'function';
};
var isEmptyChildren = function isEmptyChildren(children) {
  return !isFunctionChildren(children) && Children.count(children) === 0;
};
var mergeAdapterArgs = function mergeAdapterArgs(previousAdapterArgs, _ref) {
  var nextAdapterArgs = _ref.adapterArgs,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options;
  return options.shouldOverwrite ? nextAdapterArgs : merge(previousAdapterArgs, nextAdapterArgs);
};

var AdapterStates = {
  UNCONFIGURED: 'unconfigured',
  CONFIGURING: 'configuring',
  CONFIGURED: 'configured'
};
var useAppliedAdapterArgsState = function useAppliedAdapterArgsState(_ref) {
  var initialAdapterArgs = _ref.initialAdapterArgs;
  var _useState = useState(initialAdapterArgs),
    _useState2 = _slicedToArray(_useState, 2),
    appliedAdapterArgs = _useState2[0],
    setAppliedAdapterArgs = _useState2[1];
  var applyAdapterArgs = useCallback(function (nextAdapterArgs) {
    /**
     * NOTE:
     *   We can only unset `pendingAdapterArgs` after we actually perform
     *   a batched `setState` otherwise outdated `adapterArgs` as we loose
     *   the `pendingAdapterArgs` as we unset them too early.
     */
    setAppliedAdapterArgs(nextAdapterArgs);
  }, [setAppliedAdapterArgs]);
  return [appliedAdapterArgs, applyAdapterArgs];
};
var useAdapterStateRef = function useAdapterStateRef() {
  var adapterStateRef = useRef(AdapterStates.UNCONFIGURED);
  var setAdapterState = useCallback(function (nextAdapterState) {
    adapterStateRef.current = nextAdapterState;
  }, [adapterStateRef]);
  var getIsAdapterConfigured = useCallback(function () {
    return adapterStateRef.current === AdapterStates.CONFIGURED;
  }, [adapterStateRef]);
  var getDoesAdapterNeedInitialConfiguration = useCallback(function () {
    return adapterStateRef.current !== AdapterStates.CONFIGURED && adapterStateRef.current !== AdapterStates.CONFIGURING;
  }, [adapterStateRef]);
  return [adapterStateRef, setAdapterState, getIsAdapterConfigured, getDoesAdapterNeedInitialConfiguration];
};
var usePendingAdapterArgsRef = function usePendingAdapterArgsRef(appliedAdapterArgs) {
  var pendingAdapterArgsRef = useRef(undefined);
  var setPendingAdapterArgs = useCallback(function (nextReconfiguration) {
    var _pendingAdapterArgsRe;
    /**
     * NOTE:
     *    The next reconfiguration is merged into the previous
     *    one instead of maintaining a queue.
     *
     *    The first merge is merged with `appliedAdapter` args
     *    to contain the initial state (through property initializer).
     */
    pendingAdapterArgsRef.current = mergeAdapterArgs((_pendingAdapterArgsRe = pendingAdapterArgsRef.current) !== null && _pendingAdapterArgsRe !== void 0 ? _pendingAdapterArgsRe : appliedAdapterArgs, nextReconfiguration);
  }, [appliedAdapterArgs, pendingAdapterArgsRef]);
  var unsetPendingAdapterArgs = useCallback(function () {
    pendingAdapterArgsRef.current = undefined;
  }, [pendingAdapterArgsRef]);

  /**
   * NOTE:
   *    Whenever the adapter delays configuration pending adapterArgs will
   *    be kept on `pendingAdapterArgs`. These can either be populated
   *    from calls to `UNSAFE_componentWillReceiveProps` or through `ReconfigureFlopflip`.
   *    Both cases go through `reconfigureOrQueue`.
   *
   *    In any case, when the adapter should be configured it should either
   *    be passed pending or applied adapterArgs.
   *
   */
  var getAdapterArgsForConfiguration = useCallback(function () {
    var _pendingAdapterArgsRe2;
    return (_pendingAdapterArgsRe2 = pendingAdapterArgsRef.current) !== null && _pendingAdapterArgsRe2 !== void 0 ? _pendingAdapterArgsRe2 : appliedAdapterArgs;
  }, [appliedAdapterArgs, pendingAdapterArgsRef]);

  /**
   * NOTE: Clears the pending adapter args when applied adapter args changed.
   */
  useEffect(unsetPendingAdapterArgs, [appliedAdapterArgs, unsetPendingAdapterArgs]);
  return [pendingAdapterArgsRef, setPendingAdapterArgs, getAdapterArgsForConfiguration];
};
var useHandleDefaultFlagsCallback = function useHandleDefaultFlagsCallback(_ref2) {
  var onFlagsStateChange = _ref2.onFlagsStateChange;
  var handleDefaultFlags = useCallback(function (defaultFlags) {
    if (Object.keys(defaultFlags).length > 0) {
      onFlagsStateChange({
        flags: defaultFlags
      });
    }
  }, [onFlagsStateChange]);
  return handleDefaultFlags;
};
var useConfigurationEffect = function useConfigurationEffect(_ref3) {
  var adapter = _ref3.adapter,
    shouldDeferAdapterConfiguration = _ref3.shouldDeferAdapterConfiguration,
    getDoesAdapterNeedInitialConfiguration = _ref3.getDoesAdapterNeedInitialConfiguration,
    setAdapterState = _ref3.setAdapterState,
    onFlagsStateChange = _ref3.onFlagsStateChange,
    onStatusStateChange = _ref3.onStatusStateChange,
    applyAdapterArgs = _ref3.applyAdapterArgs,
    getAdapterArgsForConfiguration = _ref3.getAdapterArgsForConfiguration,
    getIsAdapterConfigured = _ref3.getIsAdapterConfigured,
    pendingAdapterArgsRef = _ref3.pendingAdapterArgsRef,
    appliedAdapterArgs = _ref3.appliedAdapterArgs;
  useEffect(function () {
    if (!shouldDeferAdapterConfiguration && getDoesAdapterNeedInitialConfiguration()) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.configure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange: onFlagsStateChange,
        onStatusStateChange: onStatusStateChange
      }).then(function (configuration) {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        var isAdapterWithoutInitializationStatus = !(configuration !== null && configuration !== void 0 && configuration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || configuration.initializationStatus === AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
          if (pendingAdapterArgsRef.current) {
            applyAdapterArgs(pendingAdapterArgsRef.current);
          }
        }
      }).catch(function () {
        warning(false, '@flopflip/react: adapter could not be configured.');
      });
    }
    if (getIsAdapterConfigured()) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.reconfigure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange: onFlagsStateChange,
        onStatusStateChange: onStatusStateChange
      }).then(function (reconfiguration) {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        var isAdapterWithoutInitializationStatus = !(reconfiguration !== null && reconfiguration !== void 0 && reconfiguration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || reconfiguration.initializationStatus === AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
        }
      }).catch(function () {
        warning(false, '@flopflip/react: adapter could not be reconfigured.');
      });
    }
  }, [adapter, shouldDeferAdapterConfiguration, onFlagsStateChange, onStatusStateChange, applyAdapterArgs, getAdapterArgsForConfiguration, getDoesAdapterNeedInitialConfiguration, getIsAdapterConfigured, setAdapterState, pendingAdapterArgsRef, appliedAdapterArgs]);
};
var useDefaultFlagsEffect = function useDefaultFlagsEffect(_ref4) {
  var adapter = _ref4.adapter,
    defaultFlags = _ref4.defaultFlags,
    onFlagsStateChange = _ref4.onFlagsStateChange,
    onStatusStateChange = _ref4.onStatusStateChange,
    setAdapterState = _ref4.setAdapterState,
    pendingAdapterArgsRef = _ref4.pendingAdapterArgsRef,
    shouldDeferAdapterConfiguration = _ref4.shouldDeferAdapterConfiguration,
    applyAdapterArgs = _ref4.applyAdapterArgs,
    getAdapterArgsForConfiguration = _ref4.getAdapterArgsForConfiguration;
  var handleDefaultFlags = useHandleDefaultFlagsCallback({
    onFlagsStateChange: onFlagsStateChange
  });
  useEffect(function () {
    if (defaultFlags) handleDefaultFlags(defaultFlags);
    if (!shouldDeferAdapterConfiguration) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.configure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange: onFlagsStateChange,
        onStatusStateChange: onStatusStateChange
      }).then(function (configuration) {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        var isAdapterWithoutInitializationStatus = !(configuration !== null && configuration !== void 0 && configuration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || configuration.initializationStatus === AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
          if (pendingAdapterArgsRef.current) {
            applyAdapterArgs(pendingAdapterArgsRef.current);
          }
        }
      }).catch(function () {
        warning(false, '@flopflip/react: adapter could not be configured.');
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};
var usePendingAdapterArgsEffect = function usePendingAdapterArgsEffect(_ref5) {
  var adapterArgs = _ref5.adapterArgs,
    appliedAdapterArgs = _ref5.appliedAdapterArgs,
    applyAdapterArgs = _ref5.applyAdapterArgs,
    getIsAdapterConfigured = _ref5.getIsAdapterConfigured,
    setPendingAdapterArgs = _ref5.setPendingAdapterArgs;
  /**
   * NOTE:
   *   This is passed through the React context (it's a public API).
   *   Internally this component has a `ReconfigureAdapter` type;
   *   this function has two arguments for clarify.
   */
  var reconfigureOrQueue = useCallback(function (nextAdapterArgs, options) {
    if (getIsAdapterConfigured()) {
      applyAdapterArgs(mergeAdapterArgs(appliedAdapterArgs, {
        adapterArgs: nextAdapterArgs,
        options: options
      }));
      return;
    }
    setPendingAdapterArgs({
      adapterArgs: nextAdapterArgs,
      options: options
    });
  }, [appliedAdapterArgs, applyAdapterArgs, getIsAdapterConfigured, setPendingAdapterArgs]);
  useEffect(function () {
    if (!getIsAdapterConfigured()) {
      reconfigureOrQueue(adapterArgs, {
        shouldOverwrite: false
      });
    }
  }, [adapterArgs, getIsAdapterConfigured, reconfigureOrQueue]);
  return [reconfigureOrQueue];
};
function ConfigureAdapter(props) {
  var _props$adapter$effect;
  var _useAppliedAdapterArg = useAppliedAdapterArgsState({
      initialAdapterArgs: props.adapterArgs
    }),
    _useAppliedAdapterArg2 = _slicedToArray(_useAppliedAdapterArg, 2),
    appliedAdapterArgs = _useAppliedAdapterArg2[0],
    applyAdapterArgs = _useAppliedAdapterArg2[1];
  var _usePendingAdapterArg = usePendingAdapterArgsRef(appliedAdapterArgs),
    _usePendingAdapterArg2 = _slicedToArray(_usePendingAdapterArg, 3),
    pendingAdapterArgsRef = _usePendingAdapterArg2[0],
    setPendingAdapterArgs = _usePendingAdapterArg2[1],
    getAdapterArgsForConfiguration = _usePendingAdapterArg2[2];
  var _useAdapterStateRef = useAdapterStateRef(),
    _useAdapterStateRef2 = _slicedToArray(_useAdapterStateRef, 4),
    setAdapterState = _useAdapterStateRef2[1],
    getIsAdapterConfigured = _useAdapterStateRef2[2],
    getDoesAdapterNeedInitialConfiguration = _useAdapterStateRef2[3];
  useDefaultFlagsEffect({
    adapter: props.adapter,
    defaultFlags: props.defaultFlags,
    onFlagsStateChange: props.onFlagsStateChange,
    onStatusStateChange: props.onStatusStateChange,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    setAdapterState: setAdapterState,
    pendingAdapterArgsRef: pendingAdapterArgsRef,
    getAdapterArgsForConfiguration: getAdapterArgsForConfiguration,
    applyAdapterArgs: applyAdapterArgs
  });
  var _usePendingAdapterArg3 = usePendingAdapterArgsEffect({
      adapterArgs: props.adapterArgs,
      appliedAdapterArgs: appliedAdapterArgs,
      applyAdapterArgs: applyAdapterArgs,
      getIsAdapterConfigured: getIsAdapterConfigured,
      setPendingAdapterArgs: setPendingAdapterArgs
    }),
    _usePendingAdapterArg4 = _slicedToArray(_usePendingAdapterArg3, 1),
    reconfigureOrQueue = _usePendingAdapterArg4[0];
  useConfigurationEffect({
    adapter: props.adapter,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    onFlagsStateChange: props.onFlagsStateChange,
    onStatusStateChange: props.onStatusStateChange,
    setAdapterState: setAdapterState,
    pendingAdapterArgsRef: pendingAdapterArgsRef,
    getDoesAdapterNeedInitialConfiguration: getDoesAdapterNeedInitialConfiguration,
    getAdapterArgsForConfiguration: getAdapterArgsForConfiguration,
    getIsAdapterConfigured: getIsAdapterConfigured,
    applyAdapterArgs: applyAdapterArgs,
    appliedAdapterArgs: appliedAdapterArgs
  });
  var adapterEffectIdentifiers = (_props$adapter$effect = props.adapter.effectIds) !== null && _props$adapter$effect !== void 0 ? _props$adapter$effect : [props.adapter.id];
  return /*#__PURE__*/React.createElement(AdapterContext.Provider, {
    value: createAdapterContext(adapterEffectIdentifiers, reconfigureOrQueue, props.adapterStatus)
  }, function () {
    var isAdapterConfigured = props.adapter.getIsConfigurationStatus(AdapterConfigurationStatus.Configured);
    if (isAdapterConfigured) {
      if (typeof props.render === 'function') return props.render();
    }
    if (props.children && isFunctionChildren(props.children)) return props.children({
      isAdapterConfigured: isAdapterConfigured
    });
    if (props.children && !isEmptyChildren(props.children)) return React.Children.only(props.children);
    return null;
  }());
}
ConfigureAdapter.defaultProps = {
  shouldDeferAdapterConfiguration: false,
  defaultFlags: {},
  children: null,
  render: null
};
ConfigureAdapter.displayName = 'ConfigureAdapter';

var useAdapterContext = function useAdapterContext() {
  return useContext(AdapterContext);
};

function ReconfigureAdapter(props) {
  var adapterContext = useAdapterContext();
  useEffect(function () {
    adapterContext.reconfigure({
      user: props.user
    }, {
      shouldOverwrite: props.shouldOverwrite
    });
  }, [props.user, props.shouldOverwrite, adapterContext]);
  return props.children ? Children.only(props.children) : null;
}
ReconfigureAdapter.displayName = 'ReconfigureAdapter';
ReconfigureAdapter.defaultProps = {
  shouldOverwrite: false,
  children: null
};

function ToggleFeature(props) {
  if (props.untoggledComponent) warning(isValidElementType(props.untoggledComponent), "Invalid prop 'untoggledComponent' supplied to 'ToggleFeature': the prop is not a valid React component");
  if (props.toggledComponent) warning(isValidElementType(props.toggledComponent), "Invalid prop 'toggledComponent' supplied to 'ToggleFeature': the prop is not a valid React component");
  if (props.isFeatureEnabled) {
    if (props.toggledComponent) return /*#__PURE__*/React.createElement(props.toggledComponent);
    if (props.children) {
      if (typeof props.children === 'function') return props.children({
        isFeatureEnabled: props.isFeatureEnabled
      });
      return React.Children.only(props.children);
    }
    if (typeof props.render === 'function') return props.render();
  }
  if (typeof props.children === 'function') return props.children({
    isFeatureEnabled: props.isFeatureEnabled
  });
  if (props.untoggledComponent) {
    return /*#__PURE__*/React.createElement(props.untoggledComponent);
  }
  return null;
}
ToggleFeature.displayName = 'ToggleFeature';

var DEFAULT_FLAG_PROP_KEY = 'isFeatureEnabled';
var DEFAULT_FLAGS_PROP_KEY = 'featureToggles';
var ALL_FLAGS_PROP_KEY = '@flopflip/flags';

var getNormalizedFlagName = function getNormalizedFlagName(flagName) {
  return camelCase(flagName);
};

// eslint-disable-next-line no-eq-null, eqeqeq
var isNil = function isNil(value) {
  return value == null;
};

var getFlagVariation = function getFlagVariation(allFlags, adapterIdentifiers) {
  var flagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FLAG_PROP_KEY;
  var normalizedFlagName = getNormalizedFlagName(flagName);
  warning(normalizedFlagName === flagName, '@flopflip/react: passed flag name does not seem to be normalized which may result in unexpected toggling. Please refer to our readme for more information: https://github.com/tdeekens/flopflip#flag-normalization');
  var _iterator = _createForOfIteratorHelper(adapterIdentifiers),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _allFlags$adapterInte;
      var adapterInterfaceIdentifier = _step.value;
      var flagVariation = (_allFlags$adapterInte = allFlags[adapterInterfaceIdentifier]) === null || _allFlags$adapterInte === void 0 ? void 0 : _allFlags$adapterInte[normalizedFlagName];
      if (!isNil(flagVariation)) {
        return flagVariation;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return false;
};

var getIsFeatureEnabled = function getIsFeatureEnabled(allFlags, adapterIdentifiers) {
  var flagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FLAG_PROP_KEY;
  var flagVariation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return getFlagVariation(allFlags, adapterIdentifiers, flagName) === flagVariation;
};

var setDisplayName = (function (nextDisplayName) {
  return function (BaseComponent) {
    BaseComponent.displayName = nextDisplayName;
    return BaseComponent;
  };
});

function wrapDisplayName(BaseComponent, hocName) {
  var _BaseComponent$displa;
  var previousDisplayName = (_BaseComponent$displa = BaseComponent.displayName) !== null && _BaseComponent$displa !== void 0 ? _BaseComponent$displa : BaseComponent.name;
  return "".concat(hocName, "(").concat(previousDisplayName !== null && previousDisplayName !== void 0 ? previousDisplayName : 'Component', ")");
}

function useAdapterReconfiguration() {
  var adapterContext = useContext(AdapterContext);
  return adapterContext.reconfigure;
}

function useAdapterSubscription(adapter) {
  /**
   * NOTE:
   *    This state needs to be duplicated in a React.ref
   *    as under test multiple instances of flopflip might
   *    be rendered. This yields in them competing in adapter
   *    subscription state (e.g. A unsubscribing and B subscribing
   *    which yields A and B being subscribed as the adapter
   *    is a singleton).
   */
  var useAdapterSubscriptionStatusRef = useRef(AdapterSubscriptionStatus.Subscribed);
  var subscribe = adapter.subscribe,
    unsubscribe = adapter.unsubscribe;
  useEffect(function () {
    if (subscribe) {
      subscribe();
    }
    useAdapterSubscriptionStatusRef.current = AdapterSubscriptionStatus.Subscribed;
    return function () {
      if (unsubscribe) {
        unsubscribe();
      }
      useAdapterSubscriptionStatusRef.current = AdapterSubscriptionStatus.Unsubscribed;
    };
  }, [subscribe, unsubscribe]);
  return useCallback(function (demandedAdapterSubscriptionStatus) {
    return useAdapterSubscriptionStatusRef.current === demandedAdapterSubscriptionStatus;
  }, [useAdapterSubscriptionStatusRef]);
}

var version = "12.3.6";

export { ALL_FLAGS_PROP_KEY, AdapterContext, ConfigureAdapter, DEFAULT_FLAGS_PROP_KEY, DEFAULT_FLAG_PROP_KEY, ReconfigureAdapter, ToggleFeature, createAdapterContext, getFlagVariation, getIsFeatureEnabled, isNil, selectAdapterConfigurationStatus, setDisplayName, useAdapterContext, useAdapterReconfiguration, useAdapterSubscription, version, wrapDisplayName };
